.DEFAULT_GOAL := help

# Variables
ENV ?= dev
TERRAFORM_DIR = .
VAR_FILE = environments/$(ENV)/terraform.tfvars

# Colors for output
RED = \033[0;31m
GREEN = \033[0;32m
YELLOW = \033[1;33m
BLUE = \033[0;34m
NC = \033[0m # No Color

.PHONY: help
help: ## ğŸ“œ Show this help message
	@echo "Terraform deployment commands for Customer Service"
	@echo ""
	@echo "Usage: make <command> [ENV=dev|staging|prod]"
	@echo ""
	@awk 'BEGIN {FS = ":.*##"; } /^[a-zA-Z_-]+:.*?##/ { printf "  $(GREEN)%-20s$(NC) %s\n", $$1, $$2 }' $(MAKEFILE_LIST)
	@echo ""

.PHONY: validate-env
validate-env: ## âœ… Validate environment
	@if [ ! -f "$(VAR_FILE)" ]; then \
		echo "$(RED)âŒ Environment file not found: $(VAR_FILE)$(NC)"; \
		echo "$(BLUE)ğŸ’¡ Copy from: environments/$(ENV)/terraform.tfvars.example$(NC)"; \
		exit 1; \
	fi
	@echo "$(GREEN)âœ… Environment $(ENV) is valid$(NC)"

.PHONY: check-lambda
check-lambda: ## ğŸ” Check if Lambda package exists
	@if [ ! -f "../dist/function.zip" ]; then \
		echo "$(RED)âŒ Lambda package not found: ../dist/function.zip$(NC)"; \
		echo "$(BLUE)ğŸ’¡ Run: make package (in project root)$(NC)"; \
		exit 1; \
	fi
	@echo "$(GREEN)âœ… Lambda package exists$(NC)"

.PHONY: init
init: ## ğŸš€ Initialize Terraform
	@echo "$(BLUE)ğŸ”§ Initializing Terraform...$(NC)"
	@terraform init
	@echo "$(GREEN)âœ… Terraform initialized$(NC)"

.PHONY: workspace
workspace: init ## ğŸ·ï¸  Create or select workspace
	@echo "$(BLUE)ğŸ·ï¸  Setting up workspace: $(ENV)$(NC)"
	@terraform workspace select $(ENV) 2>/dev/null || terraform workspace new $(ENV)
	@echo "$(GREEN)âœ… Workspace $(ENV) ready$(NC)"

.PHONY: validate
validate: workspace ## âœ… Validate Terraform configuration
	@echo "$(BLUE)ğŸ” Validating Terraform configuration...$(NC)"
	@terraform validate
	@echo "$(GREEN)âœ… Configuration is valid$(NC)"

.PHONY: plan
plan: validate-env check-lambda validate ## ğŸ“‹ Plan Terraform deployment
	@echo "$(BLUE)ğŸ“‹ Planning deployment for $(ENV)...$(NC)"
	@terraform plan -var-file="$(VAR_FILE)" -out="terraform-$(ENV).tfplan"
	@echo "$(GREEN)âœ… Plan created: terraform-$(ENV).tfplan$(NC)"

.PHONY: apply
apply: plan ## ğŸš€ Apply Terraform deployment
	@echo "$(BLUE)ğŸš€ Applying deployment for $(ENV)...$(NC)"
	@terraform apply "terraform-$(ENV).tfplan"
	@rm -f "terraform-$(ENV).tfplan"
	@echo "$(GREEN)âœ… Deployment completed for $(ENV)$(NC)"

.PHONY: apply-auto
apply-auto: validate-env check-lambda validate ## ğŸš€ Apply without interactive approval
	@echo "$(YELLOW)âš ï¸  Auto-applying deployment for $(ENV) (no confirmation)...$(NC)"
	@terraform apply -var-file="$(VAR_FILE)" -auto-approve
	@echo "$(GREEN)âœ… Auto-deployment completed for $(ENV)$(NC)"

.PHONY: destroy
destroy: validate-env workspace ## ğŸ’¥ Destroy infrastructure
	@echo "$(RED)ğŸ’¥ Destroying infrastructure for $(ENV)...$(NC)"
	@echo "$(YELLOW)âš ï¸  This will delete all resources!$(NC)"
	@terraform destroy -var-file="$(VAR_FILE)"
	@echo "$(RED)ğŸ’¥ Infrastructure destroyed for $(ENV)$(NC)"

.PHONY: output
output: workspace ## ğŸ“¤ Show Terraform outputs
	@echo "$(BLUE)ğŸ“¤ Terraform outputs for $(ENV):$(NC)"
	@terraform output

.PHONY: show
show: workspace ## ğŸ‘ï¸  Show current state
	@echo "$(BLUE)ğŸ‘ï¸  Current state for $(ENV):$(NC)"
	@terraform show

.PHONY: fmt
fmt: ## ğŸ¨ Format Terraform files
	@echo "$(BLUE)ğŸ¨ Formatting Terraform files...$(NC)"
	@terraform fmt -recursive
	@echo "$(GREEN)âœ… Files formatted$(NC)"

.PHONY: clean
clean: ## ğŸ§¹ Clean Terraform files
	@echo "$(BLUE)ğŸ§¹ Cleaning Terraform files...$(NC)"
	@rm -rf .terraform/
	@rm -f *.tfplan
	@rm -f *.tfstate*
	@echo "$(GREEN)âœ… Cleaned$(NC)"

.PHONY: refresh
refresh: validate-env workspace ## ğŸ”„ Refresh Terraform state
	@echo "$(BLUE)ğŸ”„ Refreshing state for $(ENV)...$(NC)"
	@terraform refresh -var-file="$(VAR_FILE)"
	@echo "$(GREEN)âœ… State refreshed$(NC)"

.PHONY: import
import: validate-env workspace ## ğŸ“¥ Import existing resource
	@echo "$(BLUE)ğŸ“¥ Import resource for $(ENV):$(NC)"
	@echo "Usage: make import RESOURCE=aws_lambda_function.example ID=function-name"
	@if [ -z "$(RESOURCE)" ] || [ -z "$(ID)" ]; then \
		echo "$(RED)âŒ RESOURCE and ID are required$(NC)"; \
		exit 1; \
	fi
	@terraform import -var-file="$(VAR_FILE)" $(RESOURCE) $(ID)

.PHONY: deploy-dev
deploy-dev: ## ğŸš€ Deploy to development
	@$(MAKE) apply ENV=dev

.PHONY: deploy-staging
deploy-staging: ## ğŸš€ Deploy to staging
	@$(MAKE) apply ENV=staging

.PHONY: deploy-prod
deploy-prod: ## ğŸš€ Deploy to production
	@$(MAKE) apply ENV=prod

.PHONY: status
status: ## ğŸ“Š Show deployment status
	@echo "$(BLUE)ğŸ“Š Deployment Status$(NC)"
	@echo "Current workspace: $$(terraform workspace show)"
	@echo "Environment: $(ENV)"
	@echo "Config file: $(VAR_FILE)"
	@if [ -f "$(VAR_FILE)" ]; then \
		echo "$(GREEN)âœ… Config exists$(NC)"; \
	else \
		echo "$(RED)âŒ Config missing$(NC)"; \
	fi
	@if [ -f "../dist/function.zip" ]; then \
		echo "$(GREEN)âœ… Lambda package ready$(NC)"; \
	else \
		echo "$(RED)âŒ Lambda package missing$(NC)"; \
	fi

.PHONY: endpoints
endpoints: workspace ## ğŸŒ Show API endpoints
	@echo "$(BLUE)ğŸŒ API Endpoints for $(ENV):$(NC)"
	@terraform output -json customer_api_endpoints | jq -r 'to_entries[] | "\(.key): \(.value)"'

.PHONY: logs
logs: workspace ## ğŸ“ Show recent Lambda logs
	@echo "$(BLUE)ğŸ“ Recent Lambda logs for $(ENV):$(NC)"
	@FUNCTION_NAME=$$(terraform output -raw lambda_function_name) && \
	aws logs tail "/aws/lambda/$$FUNCTION_NAME" --follow

.PHONY: test-api
test-api: workspace ## ğŸ§ª Test deployed API
	@echo "$(BLUE)ğŸ§ª Testing deployed API for $(ENV):$(NC)"
	@API_URL=$$(terraform output -raw api_gateway_url) && \
	echo "Testing: $$API_URL/customers" && \
	curl -s "$$API_URL/customers" | jq .